<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 油菜持笔</title><link>http://yccb.me/posts/</link><description>Recent content in Posts on 油菜持笔</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 27 Jan 2020 00:18:20 +0800</lastBuildDate><atom:link href="http://yccb.me/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>c++中的CRTP</title><link>http://yccb.me/posts/crtp/</link><pubDate>Mon, 27 Jan 2020 00:18:20 +0800</pubDate><guid>http://yccb.me/posts/crtp/</guid><description>最近在学习boost::beast的时候，注意到了在自定义parser的地方，有这么一种设计：
1template&amp;lt;bool isRequest&amp;gt; 2class custom_parser 3 : public basic_parser&amp;lt;isRequest, custom_parser&amp;lt;isRequest&amp;gt;&amp;gt; 根据上面的说法，这种设计模式叫做CRTP，中文wiki翻译成&amp;quot;奇异递归模版模式&amp;quot;。其实这严格来说并不是个递归（两种类型互相分别为子类和模版参数），不过确实给了我耳目一新的感觉。
那么，什么是CRTP呢？CRTP是这样的一种设计模式：
在需要使用类似于继承多态的地方使用 将基类实现成模版类，例如：A&amp;lt;Derived&amp;gt; 在派生类中，将派生类自己作为模版参数实体化基类模版，然后继承之：class B : public A&amp;lt;B&amp;gt; 本质上来说，CRTP是派生类对基类进行依赖注入的一种形式。
考虑如下的A-&amp;gt;B A-&amp;gt;C继承使用虚函数调用的情况：
1#include &amp;lt;iostream&amp;gt;2 3class A 4{ 5 public: 6 void call_func() 7 { 8 func(); 9 } 10 11 virtual void func(){} 12}; 13 14class B : public A 15{ 16 public: 17 virtual void func() 18 { 19 std::cout &amp;lt;&amp;lt; &amp;#34;B.func&amp;#34; &amp;lt;&amp;lt; std::endl; 20 } 21}; 22 23class C : public A 24{ 25 public: 26 virtual void func() 27 { 28 std::cout &amp;lt;&amp;lt; &amp;#34;C.</description></item><item><title>以版本兼容的方式使用c++20 concepts</title><link>http://yccb.me/posts/concepts-macros/</link><pubDate>Tue, 24 Sep 2019 14:54:00 +0800</pubDate><guid>http://yccb.me/posts/concepts-macros/</guid><description>c++20正式将Concept TS纳入了标准。这一feature解决了c++模版元编程长久以来存在的一个问题，就是没办法限制传入的模版参数，可能导致上层写错的代码，报错信息出现在千里之外的地方。
如果需要用的编译器不支持concepts怎么办呢？刚才提到了，仅仅用来检查输入参数的话，concept是一个没有实际功能的语法特性。这时候，我们可以利用宏做一个简单的polyfill：
1 2#pragma once 3 4#ifdef __ENABLE_CONCEPTS 5 6#define THE_TYPE TypeInDefConcept 7 8#define DEF_CONCEPT(__name, __satisfy) template&amp;lt;typename THE_TYPE&amp;gt; \ 9concept __name = requires __satisfy; 10 11#define REQ_CONCEPT(__constraint) requires __constraint 12 13#else 14 15#define THE_TYPE 16 17#define DEF_CONCEPT(__name, __satisfy) 18 19#define REQ_CONCEPT(__constraint) 20 21#endif 22 23 以cppreference上面对Concepts TS的范例来说，使用起来就是这样：
1 2#include &amp;#34;concepts.hpp&amp;#34;3 4#include &amp;lt;string&amp;gt;5#include &amp;lt;locale&amp;gt;6using namespace std::literals; 7 8// Declaration of the concept &amp;#34;EqualityComparable&amp;#34;, which is satisfied by 9// any type T such that for values a and b of type T, 10// the expression a==b compiles and its result is convertible to bool 11DEF_CONCEPT(EqualityComparable, 12 (THE_TYPE a, THE_TYPE b) 13 { 14 { a == b } -&amp;gt; bool; 15 }) 16 17template&amp;lt;typename T&amp;gt; 18void f(T&amp;amp;&amp;amp;) REQ_CONCEPT(EqualityComparable&amp;lt;T&amp;gt;) {} // declaration of a constrained function template 19 20int main() { 21 f(&amp;#34;abc&amp;#34;s); // OK, std::string is EqualityComparable 22 f(std::use_facet&amp;lt;std::ctype&amp;lt;char&amp;gt;&amp;gt;(std::locale{})); // Error: not EqualityComparable 23} 24 我们可以关闭concepts进行编译，并不会遇到任何问题：</description></item></channel></rss>